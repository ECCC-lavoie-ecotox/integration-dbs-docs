[
  {
    "objectID": "tbl_measurements.html",
    "href": "tbl_measurements.html",
    "title": "Description des contaminants",
    "section": "",
    "text": "On cherche à obtenir une liste exhaustive des contaminants mesurés chez quatre espèces impliquées dans le PASL.\n\n\nRecencement des fichiers et des feuillets (1 feuillet = 1 famille) Pour chacun des fichiers et feuillets, j’identifie la plage de colonne dans laquelle se retrouve les valeurs des contaminants (voir la liste intitulée “sheets” pour chacun des fichiers).\n\ncontaminants_mapping &lt;- list(\n    herons = list(\n        path = \"Z:/01-Projets et suivis/PASL/GrandHeron/Base de donnees GBHE oeufs.xlsx\",\n        sheets = list(\n            PFC = c(\"PFBA\", \"PFDS\"),\n            OC = c(\"1.2.4.5-Tetrachlorobenzene\", \"TCPM\"),\n            PCB = c(\"PCB18/17\", \"Aroclor1260\"),\n            BFR = c(\"BDE-7\", \"anti-DP\"),\n            `non-ortho PCBs` = c(\"PCB-81\", \"PCB-169\"),\n            `PCDDs & PCDFs` = c(\"2378-TCDD\", \"OCDF\"),\n            Toxaphene = c(\"Total toxaphene\", \"B9-1025\"),\n            FAME = c(\"Caproic Acid\", \"Docosahexaenoic Acid (DHA)\"),\n            THg = c(\"THg-dw\", \"THg-ww\"),\n            SI = c(\"d13C\", \"d34S\")\n        )\n    ),\n    eiders = list(\n        path = \"Z:/01-Projets et suivis/PASL/EiderDuvet/Base de donnees COEI.xlsx\",\n        sheets = list(\n            PFC = c(\"PFBA\", \"PFDS\"),\n            OC = c(\"1,2,4,5-Tetrachlorobenzene\", \"Mirex\"),\n            PCB = c(\"PCB17/18\", \"PCB209\"),\n            BFR = c(\"b-TBECH/BDE15\", \"BB101\"),\n            THg = c(\"THg_dw\", \"THg_ww\")\n        )\n    ),\n    gulls = list(\n        path = \"Z:/01-Projets et suivis/PASL/GoelandArgenté/Base de donnees HERG.xlsx\",\n        sheets = list(\n            PFC = c(\"PFBA\", \"PFDS\"),\n            OC = c(\"1,2,4,5-Tetrachlorobenzene\", \"Mirex\"),\n            PCB = c(\"PCB17/18\", \"PCB209\"),\n            BFR = c(\"b-TBECH/BDE15\", \"BB101\"),\n            THg = c(\"THg\", \"THg\"),\n            SI = c(\"d13C\", \"d34S\")\n        )\n    ),\n    gannets = list(\n        path = \"Z:/01-Projets et suivis/PASL/FouBassan/Stats_NOGA_Temporal2022/Integration_ST LAWRENCE_Gannets Trends 1969-2019_OC-PCB-FR Metals D-F FAME CNS.xlsx\",\n        sheets = list(\n            OC = c(\"1245TCB\", \"Mirex\"),\n            PCB = c(\"PCB18/17\", \"Aroclor1260\"),\n            BFR = c(\"BDE-15_B-TBECH\", \"anti-DP\"),\n            `Non-ortho PCBs` = c(\"PCB 81\", \"PCB 169\"),\n            `PCDDs & PCDFs` = c(\"2378-TCDD\", \"OCDF\"),\n            Metal = c(\"THg\", \"Al\"),\n            FAME = c(\"caproic acid\", \"docosahexaenoic acid (DHA)\"),\n            SI = c(\"d15N\", \"CN\")\n        )\n    )\n)\n\n\n\n\nOn effectue une double map (comme une double loop). Cette opération va extraire les valeurs de contaminants en traversant les classeurs (1 par espèce), et les feuillets (1 par famille de contaminant).\n\ncontaminants &lt;- purrr::map(\n    # Loop over species dataset\n    contaminants_mapping, \\(f){\n        # Copy the excel file locally in the temp folder\n        tmp_file &lt;- tempfile()\n        file.copy(f$path, tmp_file, overwrite = TRUE)\n        # Loop over sheets\n        purrr::map2(f$sheets, names(f$sheets), \\(s, n){\n            readxl::read_excel(tmp_file, sheet = n) |&gt;\n                dplyr::select(\"Year\", \"Location\", \"SampleID\", \"Species\", s[1]:s[2]) |&gt;\n                dplyr::mutate(source = f$path, conpound_family = n) |&gt;\n                dplyr::mutate(across(everything(), as.character)) |&gt;\n                tidyr::pivot_longer(cols = s[1]:s[2], names_to = \"variable\") |&gt;\n                dplyr::filter(!is.na(value))\n        }) |&gt; dplyr::bind_rows()\n}) |&gt; dplyr::bind_rows()\n\ncontaminants |&gt; dplyr::group_by(Location) |&gt; dplyr::summarize(\n    nSpecies = dplyr::n_distinct(Species)) |&gt; dplyr::arrange(desc(nSpecies))\n\n# A tibble: 66 × 2\n   Location                                    nSpecies\n   &lt;chr&gt;                                          &lt;int&gt;\n 1 Ile Laval                                          3\n 2 Ile aux Oeufs                                      2\n 3 Kamouraska                                         2\n 4 Missipinuk (Grosse Romaine)                        2\n 5 Archipel de Mingan (approximative location)        1\n 6 Battures aux Loups Marins                          1\n 7 Beauharnois                                        1\n 8 Betchouanes                                        1\n 9 Bonaventure                                        1\n10 Bonaventure Island                                 1\n# ℹ 56 more rows\n\n\n\n\n\nCertains noms de composées divergent entre les différents classeurs de données (espèces)\ndups_contaminants &lt;- contaminants |&gt; \n    dplyr::group_by(conpound_family, variable) |&gt;\n    dplyr::arrange(desc(variable)) |&gt;\n    dplyr::count()\n\nreactable::reactable(dups_contaminants)\n\n\nAtelier 1: Jouer a pareil, pas pareil, pour consolider la nomenclature des contaminants\n\n\n\ndups_sites &lt;- contaminants |&gt; \n    dplyr::group_by(Location) |&gt;\n    dplyr::count()\n\nreactable::reactable(dups_sites)\n\n\nAtelier 2: Jouer a pareil, pas pareil, pour consolider la nomenclature des sites\n\n\n\nOn applique la transformation avec la fonction toxbox::uncensored().\n\ncontaminants_uncensored &lt;- contaminants |&gt; \n    toxbox::uncensored(cols = \"value\", keep_cens = TRUE)\n\nWarning: There was 1 warning in `dplyr::mutate()`.\nℹ In argument: `dplyr::across(tidyselect::all_of(cols), remove_cens)`.\nCaused by warning:\n! NAs introduced by coercion\n\n\nIsolation des valeurs NA’s pour comprendre quelles sont les mesures qui ne peuvent pas être transformé en valeur numérique.\n\n\n\ntable(is.na(contaminants_uncensored$value))\n\n\nFALSE  TRUE \n31592   780 \n\n\n\n\n\n\ncontaminants_uncensored |&gt; \n    dplyr::filter(is.na(value)) |&gt;\n    dplyr::group_by(source, conpound_family) |&gt;\n    dplyr::count() |&gt;\n    dplyr::arrange(source) |&gt;\n    reactable::reactable()\n\n\n\n\n\n\n\n\nTODO: A compléter ici, marche pas\n\ncontaminants |&gt; \n    dplyr::filter(stringr::str_detect(stringr::str_trim(value), \"[:alpha:]\")) |&gt;\n    as.data.frame() |&gt;\n    reactable::reactable()",
    "crumbs": [
      "Consolider les données",
      "Description des contaminants"
    ]
  },
  {
    "objectID": "tbl_measurements.html#otenir-une-liste-exhaustive-des-contaminants",
    "href": "tbl_measurements.html#otenir-une-liste-exhaustive-des-contaminants",
    "title": "Description des contaminants",
    "section": "",
    "text": "On cherche à obtenir une liste exhaustive des contaminants mesurés chez quatre espèces impliquées dans le PASL.\n\n\nRecencement des fichiers et des feuillets (1 feuillet = 1 famille) Pour chacun des fichiers et feuillets, j’identifie la plage de colonne dans laquelle se retrouve les valeurs des contaminants (voir la liste intitulée “sheets” pour chacun des fichiers).\n\ncontaminants_mapping &lt;- list(\n    herons = list(\n        path = \"Z:/01-Projets et suivis/PASL/GrandHeron/Base de donnees GBHE oeufs.xlsx\",\n        sheets = list(\n            PFC = c(\"PFBA\", \"PFDS\"),\n            OC = c(\"1.2.4.5-Tetrachlorobenzene\", \"TCPM\"),\n            PCB = c(\"PCB18/17\", \"Aroclor1260\"),\n            BFR = c(\"BDE-7\", \"anti-DP\"),\n            `non-ortho PCBs` = c(\"PCB-81\", \"PCB-169\"),\n            `PCDDs & PCDFs` = c(\"2378-TCDD\", \"OCDF\"),\n            Toxaphene = c(\"Total toxaphene\", \"B9-1025\"),\n            FAME = c(\"Caproic Acid\", \"Docosahexaenoic Acid (DHA)\"),\n            THg = c(\"THg-dw\", \"THg-ww\"),\n            SI = c(\"d13C\", \"d34S\")\n        )\n    ),\n    eiders = list(\n        path = \"Z:/01-Projets et suivis/PASL/EiderDuvet/Base de donnees COEI.xlsx\",\n        sheets = list(\n            PFC = c(\"PFBA\", \"PFDS\"),\n            OC = c(\"1,2,4,5-Tetrachlorobenzene\", \"Mirex\"),\n            PCB = c(\"PCB17/18\", \"PCB209\"),\n            BFR = c(\"b-TBECH/BDE15\", \"BB101\"),\n            THg = c(\"THg_dw\", \"THg_ww\")\n        )\n    ),\n    gulls = list(\n        path = \"Z:/01-Projets et suivis/PASL/GoelandArgenté/Base de donnees HERG.xlsx\",\n        sheets = list(\n            PFC = c(\"PFBA\", \"PFDS\"),\n            OC = c(\"1,2,4,5-Tetrachlorobenzene\", \"Mirex\"),\n            PCB = c(\"PCB17/18\", \"PCB209\"),\n            BFR = c(\"b-TBECH/BDE15\", \"BB101\"),\n            THg = c(\"THg\", \"THg\"),\n            SI = c(\"d13C\", \"d34S\")\n        )\n    ),\n    gannets = list(\n        path = \"Z:/01-Projets et suivis/PASL/FouBassan/Stats_NOGA_Temporal2022/Integration_ST LAWRENCE_Gannets Trends 1969-2019_OC-PCB-FR Metals D-F FAME CNS.xlsx\",\n        sheets = list(\n            OC = c(\"1245TCB\", \"Mirex\"),\n            PCB = c(\"PCB18/17\", \"Aroclor1260\"),\n            BFR = c(\"BDE-15_B-TBECH\", \"anti-DP\"),\n            `Non-ortho PCBs` = c(\"PCB 81\", \"PCB 169\"),\n            `PCDDs & PCDFs` = c(\"2378-TCDD\", \"OCDF\"),\n            Metal = c(\"THg\", \"Al\"),\n            FAME = c(\"caproic acid\", \"docosahexaenoic acid (DHA)\"),\n            SI = c(\"d15N\", \"CN\")\n        )\n    )\n)\n\n\n\n\nOn effectue une double map (comme une double loop). Cette opération va extraire les valeurs de contaminants en traversant les classeurs (1 par espèce), et les feuillets (1 par famille de contaminant).\n\ncontaminants &lt;- purrr::map(\n    # Loop over species dataset\n    contaminants_mapping, \\(f){\n        # Copy the excel file locally in the temp folder\n        tmp_file &lt;- tempfile()\n        file.copy(f$path, tmp_file, overwrite = TRUE)\n        # Loop over sheets\n        purrr::map2(f$sheets, names(f$sheets), \\(s, n){\n            readxl::read_excel(tmp_file, sheet = n) |&gt;\n                dplyr::select(\"Year\", \"Location\", \"SampleID\", \"Species\", s[1]:s[2]) |&gt;\n                dplyr::mutate(source = f$path, conpound_family = n) |&gt;\n                dplyr::mutate(across(everything(), as.character)) |&gt;\n                tidyr::pivot_longer(cols = s[1]:s[2], names_to = \"variable\") |&gt;\n                dplyr::filter(!is.na(value))\n        }) |&gt; dplyr::bind_rows()\n}) |&gt; dplyr::bind_rows()\n\ncontaminants |&gt; dplyr::group_by(Location) |&gt; dplyr::summarize(\n    nSpecies = dplyr::n_distinct(Species)) |&gt; dplyr::arrange(desc(nSpecies))\n\n# A tibble: 66 × 2\n   Location                                    nSpecies\n   &lt;chr&gt;                                          &lt;int&gt;\n 1 Ile Laval                                          3\n 2 Ile aux Oeufs                                      2\n 3 Kamouraska                                         2\n 4 Missipinuk (Grosse Romaine)                        2\n 5 Archipel de Mingan (approximative location)        1\n 6 Battures aux Loups Marins                          1\n 7 Beauharnois                                        1\n 8 Betchouanes                                        1\n 9 Bonaventure                                        1\n10 Bonaventure Island                                 1\n# ℹ 56 more rows\n\n\n\n\n\nCertains noms de composées divergent entre les différents classeurs de données (espèces)\ndups_contaminants &lt;- contaminants |&gt; \n    dplyr::group_by(conpound_family, variable) |&gt;\n    dplyr::arrange(desc(variable)) |&gt;\n    dplyr::count()\n\nreactable::reactable(dups_contaminants)\n\n\nAtelier 1: Jouer a pareil, pas pareil, pour consolider la nomenclature des contaminants\n\n\n\ndups_sites &lt;- contaminants |&gt; \n    dplyr::group_by(Location) |&gt;\n    dplyr::count()\n\nreactable::reactable(dups_sites)\n\n\nAtelier 2: Jouer a pareil, pas pareil, pour consolider la nomenclature des sites\n\n\n\nOn applique la transformation avec la fonction toxbox::uncensored().\n\ncontaminants_uncensored &lt;- contaminants |&gt; \n    toxbox::uncensored(cols = \"value\", keep_cens = TRUE)\n\nWarning: There was 1 warning in `dplyr::mutate()`.\nℹ In argument: `dplyr::across(tidyselect::all_of(cols), remove_cens)`.\nCaused by warning:\n! NAs introduced by coercion\n\n\nIsolation des valeurs NA’s pour comprendre quelles sont les mesures qui ne peuvent pas être transformé en valeur numérique.\n\n\n\ntable(is.na(contaminants_uncensored$value))\n\n\nFALSE  TRUE \n31592   780 \n\n\n\n\n\n\ncontaminants_uncensored |&gt; \n    dplyr::filter(is.na(value)) |&gt;\n    dplyr::group_by(source, conpound_family) |&gt;\n    dplyr::count() |&gt;\n    dplyr::arrange(source) |&gt;\n    reactable::reactable()\n\n\n\n\n\n\n\n\nTODO: A compléter ici, marche pas\n\ncontaminants |&gt; \n    dplyr::filter(stringr::str_detect(stringr::str_trim(value), \"[:alpha:]\")) |&gt;\n    as.data.frame() |&gt;\n    reactable::reactable()",
    "crumbs": [
      "Consolider les données",
      "Description des contaminants"
    ]
  },
  {
    "objectID": "tbl_measurements.html#objectif-2-déterminer-la-taille-déchantillons",
    "href": "tbl_measurements.html#objectif-2-déterminer-la-taille-déchantillons",
    "title": "Description des contaminants",
    "section": "Objectif 2: Déterminer la taille d’échantillons",
    "text": "Objectif 2: Déterminer la taille d’échantillons\nOn compte le nombre de mesures pour chaque combinaison.\ndata_count &lt;- contaminants |&gt; \n    dplyr::mutate(Year = as.integer(Year)) |&gt;\n    toxbox::uncensored(cols = \"value\", keep_cens = TRUE) |&gt;\n    dplyr::group_by(Location, Year, Species, conpound_family, variable) |&gt;\n    dplyr::summarise(n = dplyr::n(), n_censored = sum(value_censored))\nWarning: There was 1 warning in `dplyr::mutate()`.\nℹ In argument: `dplyr::across(tidyselect::all_of(cols), remove_cens)`.\nCaused by warning:\n! NAs introduced by coercion\n`summarise()` has grouped output by 'Location', 'Year', 'Species',\n'conpound_family'. You can override using the `.groups` argument.\n\ndata_count |&gt;\n    reactable::reactable()\n\n\n\n\n\n\nCriteria 1. On retire les sites pour lesquelles, il y a une seule année de collecte (impossibilité de calibrer un modèle de tendance temporelle).\nVoici la liste des sites pour lesquelles, on a une seule année de mesure\ncrit1 &lt;- contaminants |&gt; \n    dplyr::select(Location, Year) |&gt;\n    dplyr::distinct() |&gt;\n    dplyr::group_by(Location) |&gt;\n    dplyr::count() |&gt;\n    dplyr::filter(n == 1) |&gt;\n    dplyr::pull(Location)\n\ncat(paste(\"*\", crit1), sep=\"\\n\")\n\nArchipel de Mingan (approximative location)\nBeauharnois\nBetchouanes\nBonaventure\nDeslauriers\nEscuminac\nGros Pot\nIle Beauséjour\nIle Bellechasse\nIle Bienville\nIle Blanche\nIle Dodens\nIle Dowker\nIle Nue\nIle Saint-Barnabé\nIle a Bouleau de Terre\nIle aux Pommes\nIle de la Madeleine\nIle de la Mine\nIle du Petit Caoui\nIle du Petit Caouis\nIle à Calculot des Betchouanes\nIles aux Loups Marins\nIles de la Madeleine\nIlets Boisés\nIlets De Quen\nKamouraska\nKukuministuk (Caye à Cochons)\nLac Bleu\nLac Evans\nLac Saint-Bernard\nLac St-Pierre\nLac à la Carpe\nLong Island\nMiller island\nMissipinuk (Grosse Romaine)\nPetit Lac Jacques Cartier\nPetite Ile Ste-Geneviève\nPointe Saint-Pancrace\nPrairie du Castor\nRiviere George\n\nOn retire ces sites pour l’étude de la taille de l’échantillon\n\ndata_count &lt;- data_count |&gt;\n    dplyr::filter(!(Location %in% crit1)) |&gt;\n    dplyr::ungroup()\n\n\n\nSite Battures aux Loups Marins\n\n\n\nSite Bonaventure Island\n\n\n\nSite Grande Ile\n\n\n\nSite Ile Carillon\n\n\n\nSite Ile Dickerson\n\n\n\nSite Ile Eaton\n\n\n\nSite Ile Laval\n\n\n\nSite Ile Manowin\n\n\n\nSite Ile Matane\n\n\n\nSite Ile Saint-Bernard\n\n\n\nSite Ile Steamboat\n\n\n\nSite Ile Villemomble\n\n\n\nSite Ile aux Basques\n\n\n\nSite Ile aux Herons\n\n\n\nSite Ile aux Hérons\n\n\n\nSite Ile aux Oeufs\n\n\n\nSite Ile de Carillon\n\n\n\nSite Ile de la Corneille\n\n\n\nSite Ile du Bic\n\n\n\nSite Ile du Corossol\n\n\n\nSite Iles Sainte-Marie\n\n\n\nSite Maria\n\n\n\nSite Petit lac Jacques-Cartier\n\n\n\nSite Refuge Watshishou\n\n\n\nSite Yamachiche",
    "crumbs": [
      "Consolider les données",
      "Description des contaminants"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "À quoi sert cette documentation?",
    "section": "",
    "text": "Le laboratoire de Raphael Lavoie effectue un travail d’intégration des données issues de mesure de contaminants sur des matrices biologiques pour une région d’étude couvrant l’Estuaire et le Golf du Saint-Laurent.\nCe travail d’intégration requière plusieurs étapes de validation et de consolidation des données. Ce document recense l’ensembles des étapes qui ont mener vers la construction de la base de données. Il rassemble également le code permettant de générer certaines figures exploratoires pour bien comprendre les données.",
    "crumbs": [
      "Introduction",
      "À quoi sert cette documentation?"
    ]
  },
  {
    "objectID": "deploy.html",
    "href": "deploy.html",
    "title": "Contribuer à cette documentation",
    "section": "",
    "text": "Pour construire cette documentation en locale, voici les étapes.",
    "crumbs": [
      "Introduction",
      "Contribuer à cette documentation"
    ]
  },
  {
    "objectID": "deploy.html#pré-requis",
    "href": "deploy.html#pré-requis",
    "title": "Contribuer à cette documentation",
    "section": "Pré-requis",
    "text": "Pré-requis\nInstaller les deux librairies R à l’aide des commandes suivantes:\n# install.packages(\"devtools\")\ndevtools::install_github(\"ECCC-lavoie-ecotox/toxbox\")\ninstall.packages(\"quarto\")",
    "crumbs": [
      "Introduction",
      "Contribuer à cette documentation"
    ]
  },
  {
    "objectID": "deploy.html#téleverser-le-code-source-sur-votre-poste-de-travail",
    "href": "deploy.html#téleverser-le-code-source-sur-votre-poste-de-travail",
    "title": "Contribuer à cette documentation",
    "section": "Téleverser le code source sur votre poste de travail",
    "text": "Téleverser le code source sur votre poste de travail\nTODO",
    "crumbs": [
      "Introduction",
      "Contribuer à cette documentation"
    ]
  },
  {
    "objectID": "deploy.html#construire-ce-site-internet",
    "href": "deploy.html#construire-ce-site-internet",
    "title": "Contribuer à cette documentation",
    "section": "Construire ce site internet",
    "text": "Construire ce site internet\n# Serve the website in your browser\nquarto::quarto_preview()\nCette approche permet de travailler en parallele sur les fichiers de documentation. À chaque fois qu’un fichier est modifié, le site internet est reconstruit pour inclure les dernières modifications.",
    "crumbs": [
      "Introduction",
      "Contribuer à cette documentation"
    ]
  },
  {
    "objectID": "tbl_analytes.html",
    "href": "tbl_analytes.html",
    "title": "Consolidation de la nomenclature des analytes",
    "section": "",
    "text": "Nous désirons consolider la nomenclature des analytes. On peut observer plusieurs divergences dans la facon de nommer les analytes, exemple PCB-17 ou PCB 17. Cette section documente la démarche pour tendre vers une réconciliation des termes utilisés.\nOn charge les données intégrées depuis le package toxbox. Les données ne sont pas entreposées dans le package, la function toxbox::dbs_integration() permet de lire les fichiers Excels entreposées sur le disque réseau Z: et les fusionne dans un seul data.frame. Il faut pour cela que le VPN soit ouvert, si vous n’êtes pas directement sur le réseau d’environnement canada.\ndevtools::install_github(\"ECCC-lavoie-ecotox/toxbox\")\n\nSkipping install of 'toxbox' from a github remote, the SHA1 (b95a07f6) has not changed since last install.\n  Use `force = TRUE` to force installation\nmeasurements &lt;- toxbox::dbs_integration()",
    "crumbs": [
      "Consolider les données",
      "Consolidation de la nomenclature des analytes"
    ]
  },
  {
    "objectID": "tbl_analytes.html#analytes-avec-un-numéro-cas-fournis-par-le-laboratoire",
    "href": "tbl_analytes.html#analytes-avec-un-numéro-cas-fournis-par-le-laboratoire",
    "title": "Consolidation de la nomenclature des analytes",
    "section": "Analytes avec un numéro CAS fournis par le laboratoire",
    "text": "Analytes avec un numéro CAS fournis par le laboratoire\nLa nomenclature des composées chimiques / analytes peut diverger d’un laboratoire à un autre. Chaque pays dispose également de sa propre nomenclature (ex. États-Unis, Allemagne, Royaume-Unis). Afin de reconcilier la nomenclature, nous souhaitons utiliser un identifiant unique international tel que l’International Chemical Identifier (InChl).\nDans un premier temps, on charge les données sur les analytes (incluant le CAS) fournies par les laboratoires. Le fichier analytes_consolidation_27032024 est la fusion des onglets Analyte Information des différentes base de données. On fusionne les données sur les analytes avec les mesures.\n\nanalytes &lt;- readxl::read_excel(\"Z:/07-Données BD/TBL_analytes/analytes_consolidation_27032024.xlsx\") |&gt;\n    dplyr::select(Analyte, CASNumber) |&gt;\n    dplyr::filter(!is.na(CASNumber)) |&gt;\n    dplyr::mutate(\n        key = janitor::make_clean_names(Analyte, allow_dupes = TRUE, case = \"none\") |&gt; tolower()\n    ) |&gt;\n    dplyr::distinct()\n\nmeasurements &lt;- measurements |&gt; \n    dplyr::mutate(\n        key = stringr::str_replace(variable, \"PCB-|PCB \", \"PCB\") |&gt;\n            janitor::make_clean_names(allow_dupes = TRUE, case = \"none\") |&gt; tolower()\n    )\n\nmeasurements &lt;-  measurements |&gt;\n    dplyr::left_join(analytes, by = \"key\")\n\nOn isole le nom des contaminants pour lesquels nous n’avons pas de CAS associés. Voici la liste de ces contaminants:\ncontaminants_orphelins &lt;- measurements |&gt; \n    dplyr::filter(is.na(CASNumber)) |&gt;\n    dplyr::select(key, variable, CASNumber) |&gt;\n    dplyr::distinct()\n\nreactable::reactable(contaminants_orphelins, searchable = TRUE)",
    "crumbs": [
      "Consolider les données",
      "Consolidation de la nomenclature des analytes"
    ]
  },
  {
    "objectID": "tbl_analytes.html#obtention-du-numéro-de-cas-par-le-service-cts",
    "href": "tbl_analytes.html#obtention-du-numéro-de-cas-par-le-service-cts",
    "title": "Consolidation de la nomenclature des analytes",
    "section": "Obtention du numéro de CAS par le service CTS",
    "text": "Obtention du numéro de CAS par le service CTS\nLa fonction webchem::cts_convert() permet d’interroger plusieurs base de données de référence sur des composées chimiques et d’extraire des identifiants tels que le CAS à partir du nom d’un composé chimique. La fonction webchem::cts_convert() s’interface sur le service https://cts.fiehnlab.ucdavis.edu/.\n\ncas_from_cts &lt;- webchem::cts_convert(contaminants_orphelins$variable, from = \"Chemical Name\", to = \"CAS\", match = \"first\")\n\ncas &lt;- purrr::map2_df(names(cas_from_cts), cas_from_cts, \\(n, c){\n    return(data.frame(variable = n, CASNumber = c))\n})\n\nreactable::reactable(cas, searchable = TRUE)\n\n\n\n\n\nEn cherchant le numéro CAS avec le nom du composé, on s’apercoit que plusieurs PCB (ex. PCB 60 et 64) tombent sous le même CAS, ce qui est incorrect. On change donc d’approche puisque le service CTS ne semblent pas être un bon service de résolution par le nom.",
    "crumbs": [
      "Consolider les données",
      "Consolidation de la nomenclature des analytes"
    ]
  },
  {
    "objectID": "tbl_analytes.html#obtention-du-numéro-de-cas-par-le-service-chemspider-csid",
    "href": "tbl_analytes.html#obtention-du-numéro-de-cas-par-le-service-chemspider-csid",
    "title": "Consolidation de la nomenclature des analytes",
    "section": "Obtention du numéro de CAS par le service ChemSpider (csid)",
    "text": "Obtention du numéro de CAS par le service ChemSpider (csid)\nCe service est fournis par la Société Royale de Chimie. C’est un des services qui semble être robuste pour obtenir un identifiant unique à partir du nom du composé. Une fois, l’identifiant ChemSpider obtenue il est possible d’obtenir le numéro CAS en utilisant le service https://cts.fiehnlab.ucdavis.edu/. On utilise ce service pour effectuer la conversion d’identifiants entre nomenclature (ex. csid vers CAS). Attention, ce service requière l’enregistrement d’un compte et le nombre de requête est limités à 1000 appels par mois.\n\ncsid &lt;- webchem::get_csid(contaminants_orphelins$variable, from = \"name\") \ncsid &lt;- csid |&gt; dplyr::rename(variable = query) |&gt; \n    dplyr::left_join(\n        dplyr::select(contaminants_orphelins, key, variable)\n    ) |&gt; \n    dplyr::filter(!is.na(csid)) |&gt;\n    dplyr::mutate(csid = as.character(csid))\nsaveRDS(csid, \"data/csid.rds\")\n\n\nif(!exists(\"csid\")) csid &lt;- readRDS(\"data/csid.rds\")\n\ncas_from_csid &lt;- webchem::cts_convert(csid$csid, from = \"ChemSpider\", to = \"CAS\", match = \"first\")\n\ncas2 &lt;- purrr::map2_df(names(cas_from_csid), cas_from_csid, \\(n, c){\n        return(data.frame(csid = n, CASNumber = c))\n    }) |&gt; dplyr::left_join(csid, by = \"csid\")\n\nWarning in dplyr::left_join(purrr::map2_df(names(cas_from_csid), cas_from_csid, : Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 37 of `x` matches multiple rows in `y`.\nℹ Row 37 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\nreactable::reactable(cas2, searchable = TRUE)\n\n\n\n\n\nEffectuer la résolution de la nomenclature des composées par l’utilisation du service ChemSpider semble plus prometteur. Après une vérification visuelle, on voit que les composées ne présentent plus d’identifiant unique identique.",
    "crumbs": [
      "Consolider les données",
      "Consolidation de la nomenclature des analytes"
    ]
  },
  {
    "objectID": "tbl_analytes.html#ajout-de-lidentifiant-pubchem-pubcid",
    "href": "tbl_analytes.html#ajout-de-lidentifiant-pubchem-pubcid",
    "title": "Consolidation de la nomenclature des analytes",
    "section": "Ajout de l’identifiant PubChem (pubcid)",
    "text": "Ajout de l’identifiant PubChem (pubcid)\nAfin de permettre le retrait d’informations supplémentaires sur les composées chimiques, une des base de données d’intérêt est PubChem. À partir de cette base de données, on peut effectuer le retrait de certaines propriétés chimiques du composée telles que la masse moléculaire par exemple.\n\npubcid &lt;- webchem::cts_convert(cas2$csid, from = \"ChemSpider\", to = \"PubChem CID\", match = \"first\")\n\ncas3 &lt;- purrr::map2_df(names(pubcid), pubcid, \\(n, c){\n        return(data.frame(csid = n, pubcid = c))\n    }) |&gt; dplyr::distinct() |&gt; \n        dplyr::left_join(cas2, by = \"csid\") |&gt; \n        dplyr::distinct() |&gt;\n        # On consolide le tableau final\n        dplyr::rename(casid = CASNumber) |&gt;\n        dplyr::mutate(variable = tolower(variable)) |&gt;\n        dplyr::distinct()",
    "crumbs": [
      "Consolider les données",
      "Consolidation de la nomenclature des analytes"
    ]
  },
  {
    "objectID": "tbl_analytes.html#consolidation-de-la-table-de-reference-des-analytes",
    "href": "tbl_analytes.html#consolidation-de-la-table-de-reference-des-analytes",
    "title": "Consolidation de la nomenclature des analytes",
    "section": "Consolidation de la table de reference des analytes",
    "text": "Consolidation de la table de reference des analytes\nOn a ajouté 3 identifiants pour chaque composée chimique de la base de données. Parmis, ces identifiants nous retrouvons: le CAS (casid, identifiant fournis généralement par le laboratoire d’analyse, nomenclature américaine), le ChemSpider ID (csid, nomenclature britanique) et enfin le PubChem ID (pubcid, nomenclature américaine).\nreactable::reactable(cas3, searchable = TRUE, columns = list(\n    casid = reactable::colDef(\n        cell = \\(casid){\n            if(!is.na(casid)){\n                url &lt;- paste0(\"https://commonchemistry.cas.org/detail?cas_rn=\", casid)\n                htmltools::tags$a(href = url, target = \"_blank\", casid)\n            } else { NULL }\n        }\n    ),\n    csid = reactable::colDef(\n        cell = \\(csid){\n            url &lt;- paste0(\"https://www.chemspider.com/Chemical-Structure.\", csid, \".html\")\n            htmltools::tags$a(href = url, target = \"_blank\", csid)\n        }\n    ),\n    pubcid = reactable::colDef(\n        cell = \\(pubcid){\n            url &lt;- paste0(\"https://pubchem.ncbi.nlm.nih.gov/compound/\", pubcid)\n            htmltools::tags$a(href = url, target = \"_blank\", pubcid)\n        }\n    )\n))",
    "crumbs": [
      "Consolider les données",
      "Consolidation de la nomenclature des analytes"
    ]
  },
  {
    "objectID": "tbl_projects.html",
    "href": "tbl_projects.html",
    "title": "Recensement des projets",
    "section": "",
    "text": "Chaque rapport de laboratoire contient sur sa page de garde l’ensemble des métadonnées en lien avec le projet de recherche pour lequel cette analyse a été demandé. On désire donc extraire la page de garde de chacun des rapports de laboratoires afin d’obtenir la liste des projets.\nUn rapport de laboratoire peut être detectable dans une liste de fichier par la structure de son identifiant unique. Voici un exemple d’identifiant unique: CHEM-PCDD-00-07 ou encore MB-05-10. Ces identifiants ont une structure unique que l’on peut detecter grace à l’expression régulière suivante:\n\nregex_report_id &lt;- \"([A-Za-z]{2,5}-)?[A-Za-z]{2,5}-\\\\d{2}-\\\\d{2}\"\n\nLa variable regex_report_id sera utilisée plusieurs fois dans ce document.\nOn liste les rapports de laboratoire présents dans le dossier 03-Labo/Results Reports.\n\nreports_path &lt;- list.files(\n    \"C:/Users/VissaultS/Documents/03-Labo/Results Reports\", \n    pattern = \"*.pdf|*.docx|*.doc\", recursive = TRUE, full.names = TRUE\n)\n\n# On extrait les identifiants des rapports du nom du fichier\nreport_id &lt;- stringr::str_extract(reports_path, regex_report_id)\n\n# On obtient la signature du fichier, ca va être pratique pour detecter les fichiers dupliqués même si le nom du fichier est différent.\nfile_hash &lt;- tools::md5sum(reports_path)\n\n# On extrait l'extension du fichier\nfile_ext &lt;- reports_path |&gt; \n    strsplit(\"[.]\") |&gt; \n    purrr::map_chr(\\(e) return(e[2]))\n\n# On compose un tableau avec l'ensemble de ces informations\nreports &lt;- data.frame(\n        path = reports_path, \n        id = report_id, \n        hash = file_hash, \n        ext = file_ext\n    ) |&gt; tibble::as_tibble()\n\nNote: tools::md5sum permet de générer une signature unique propre au fichier. Ainsi deux fichiers identiques dans le contenu mais avec des noms différents pourront être identifié comme des duplicats.\nVoici la liste des fichiers identiques dans le dossier 03-Labo/Results Reports.\nreports_dup &lt;- reports |&gt; \n    tibble::as_tibble() |&gt;\n    janitor::get_dupes(-c(path)) |&gt;\n    dplyr::select(-hash)\n\nreports_dup |&gt; knitr::kable()\n\n\n\n\n\n\n\n\n\nid\next\ndupe_count\npath\n\n\n\n\nBMK-PFC-23-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/BMK-PFC-23-10_HERG-COEI_eggs2023.pdf\n\n\nBMK-PFC-23-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/EideràDuvet Rapports 1972-2023/BMK-PFC-23-10_HERG-COEI_eggs2023.pdf\n\n\nBMK-PFC-23-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/BMK-PFC-23-10_HERG-COEI_eggs2023.pdf\n\n\nCHEM-OC-22-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-22-10_GBHE-HERG2022.pdf\n\n\nCHEM-OC-22-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/CHEM-OC-22-10_GBHE-HERG2022.pdf\n\n\nCHEM-OC-22-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GrandHeron Rapports xxxx-2022/Rapports/CHEM-OC-22-10_GBHE-HERG2022.pdf\n\n\nMET-THg-22-05\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/MET-THg-22-05 - RALA01-2022_HERG-GBHEegg2022.pdf\n\n\nMET-THg-22-05\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GrandHeron Rapports xxxx-2022/Rapports/MET-THg-22-05 - RALA01-2022_HERG-GBHEegg2022.pdf\n\n\nMET-THg-22-05\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/MET-THg-22-05 - RALA01-2022_HERG-GBHEegg2022.pdf\n\n\nMET-THg-23-13\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/EideràDuvet Rapports 1972-2023/MET-THg-23-13 - RALA01-2023.pdf\n\n\nMET-THg-23-13\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/MET-THg-23-13 - RALA01-2023.pdf\n\n\nMET-THg-23-13\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/MET-THg-23-13 - RALA01-2023_OeufsCOEI-HERG2023.pdf\n\n\nTP-SI-22-09\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/TP-SI-22-09C_RALA01-2022_HERG-GBHEeggs2022.pdf\n\n\nTP-SI-22-09\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GrandHeron Rapports xxxx-2022/Rapports/TP-SI-22-09C_RALA01-2022_HERG-GBHEeggs2022.pdf\n\n\nTP-SI-22-09\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/TP-SI-22-09C_RALA01-2022_HERG-GBHEeggs2022.pdf\n\n\nCHEM-OC-21-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-21-08R.pdf\n\n\nCHEM-OC-21-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/FouBassan Rapports 1984-2019/CHEM-OC-21-08R.pdf\n\n\nCHEM-OC-22-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-22-05_HERGDeslauriers.pdf\n\n\nCHEM-OC-22-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/CHEM-OC-22-05_HERGDeslauriers.pdf\n\n\nCHEM-OC-23-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-23-08_EggHERG_COEI_2023.pdf\n\n\nCHEM-OC-23-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/EideràDuvet Rapports 1972-2023/CHEM-OC-23-08_EggHERG_COEI_2023.pdf\n\n\nMET-THg-21-03\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/FouBassan Rapports 1984-2019/MET-THg-21-03.pdf\n\n\nMET-THg-21-03\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/MET-THg-21-03 - RALA01-2021_eggs.pdf\n\n\nTP-SI-21-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/FouBassan Rapports 1984-2019/TP-SI-21-05C.pdf\n\n\nTP-SI-21-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/TP-SI-21-05C_RALA01-2021.pdf\n\n\n\nOn selectionne le premier rapport en se basant sur le id (ex. BMK-PFC-23-01) pour éliminer les rapports dupliqués pour la suite de l’analyse. On s’assure de selectionner préférablement les pdfs si on dispose d’un docx et d’un document pdf pour le même identifiant de rapport de laboratoire.\n\nreports &lt;- reports |&gt; \n    # On retire les rapports qui sont dupliqués\n    dplyr::group_by(hash) |&gt;\n    dplyr::slice(1) |&gt;\n    dplyr::ungroup() |&gt;\n    # Si plusieurs extension de fichiers, on selectionne ceux en PDF préférablement, sinon .docx, sinon .doc en dernier recours.\n    dplyr::group_split(id) |&gt;\n    purrr::map(\\(g){\n        g |&gt; dplyr::arrange(factor(ext, levels = c('pdf', 'docx', 'doc'))) |&gt;\n        dplyr::slice(1)\n    }) |&gt;\n    dplyr::bind_rows()\n\nQuelques rapports de laboratoire demeurent au format doc et docx.\ndocs &lt;- reports |&gt; dplyr::filter(ext %in% c('doc', 'docx')) \ndocs |&gt; knitr::kable()\n\n\n\npath\nid\nhash\next\n\n\n\n\n\nAfin de faciliter l’extraction des métadonnées par programmation, on convertit les fichiers .doc et .docx en pdf.",
    "crumbs": [
      "Consolider les données",
      "Recensement des projets"
    ]
  },
  {
    "objectID": "tbl_projects.html#établir-une-liste-des-projets",
    "href": "tbl_projects.html#établir-une-liste-des-projets",
    "title": "Recensement des projets",
    "section": "",
    "text": "Chaque rapport de laboratoire contient sur sa page de garde l’ensemble des métadonnées en lien avec le projet de recherche pour lequel cette analyse a été demandé. On désire donc extraire la page de garde de chacun des rapports de laboratoires afin d’obtenir la liste des projets.\nUn rapport de laboratoire peut être detectable dans une liste de fichier par la structure de son identifiant unique. Voici un exemple d’identifiant unique: CHEM-PCDD-00-07 ou encore MB-05-10. Ces identifiants ont une structure unique que l’on peut detecter grace à l’expression régulière suivante:\n\nregex_report_id &lt;- \"([A-Za-z]{2,5}-)?[A-Za-z]{2,5}-\\\\d{2}-\\\\d{2}\"\n\nLa variable regex_report_id sera utilisée plusieurs fois dans ce document.\nOn liste les rapports de laboratoire présents dans le dossier 03-Labo/Results Reports.\n\nreports_path &lt;- list.files(\n    \"C:/Users/VissaultS/Documents/03-Labo/Results Reports\", \n    pattern = \"*.pdf|*.docx|*.doc\", recursive = TRUE, full.names = TRUE\n)\n\n# On extrait les identifiants des rapports du nom du fichier\nreport_id &lt;- stringr::str_extract(reports_path, regex_report_id)\n\n# On obtient la signature du fichier, ca va être pratique pour detecter les fichiers dupliqués même si le nom du fichier est différent.\nfile_hash &lt;- tools::md5sum(reports_path)\n\n# On extrait l'extension du fichier\nfile_ext &lt;- reports_path |&gt; \n    strsplit(\"[.]\") |&gt; \n    purrr::map_chr(\\(e) return(e[2]))\n\n# On compose un tableau avec l'ensemble de ces informations\nreports &lt;- data.frame(\n        path = reports_path, \n        id = report_id, \n        hash = file_hash, \n        ext = file_ext\n    ) |&gt; tibble::as_tibble()\n\nNote: tools::md5sum permet de générer une signature unique propre au fichier. Ainsi deux fichiers identiques dans le contenu mais avec des noms différents pourront être identifié comme des duplicats.\nVoici la liste des fichiers identiques dans le dossier 03-Labo/Results Reports.\nreports_dup &lt;- reports |&gt; \n    tibble::as_tibble() |&gt;\n    janitor::get_dupes(-c(path)) |&gt;\n    dplyr::select(-hash)\n\nreports_dup |&gt; knitr::kable()\n\n\n\n\n\n\n\n\n\nid\next\ndupe_count\npath\n\n\n\n\nBMK-PFC-23-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/BMK-PFC-23-10_HERG-COEI_eggs2023.pdf\n\n\nBMK-PFC-23-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/EideràDuvet Rapports 1972-2023/BMK-PFC-23-10_HERG-COEI_eggs2023.pdf\n\n\nBMK-PFC-23-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/BMK-PFC-23-10_HERG-COEI_eggs2023.pdf\n\n\nCHEM-OC-22-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-22-10_GBHE-HERG2022.pdf\n\n\nCHEM-OC-22-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/CHEM-OC-22-10_GBHE-HERG2022.pdf\n\n\nCHEM-OC-22-10\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GrandHeron Rapports xxxx-2022/Rapports/CHEM-OC-22-10_GBHE-HERG2022.pdf\n\n\nMET-THg-22-05\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/MET-THg-22-05 - RALA01-2022_HERG-GBHEegg2022.pdf\n\n\nMET-THg-22-05\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GrandHeron Rapports xxxx-2022/Rapports/MET-THg-22-05 - RALA01-2022_HERG-GBHEegg2022.pdf\n\n\nMET-THg-22-05\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/MET-THg-22-05 - RALA01-2022_HERG-GBHEegg2022.pdf\n\n\nMET-THg-23-13\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/EideràDuvet Rapports 1972-2023/MET-THg-23-13 - RALA01-2023.pdf\n\n\nMET-THg-23-13\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/MET-THg-23-13 - RALA01-2023.pdf\n\n\nMET-THg-23-13\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/MET-THg-23-13 - RALA01-2023_OeufsCOEI-HERG2023.pdf\n\n\nTP-SI-22-09\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/TP-SI-22-09C_RALA01-2022_HERG-GBHEeggs2022.pdf\n\n\nTP-SI-22-09\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GrandHeron Rapports xxxx-2022/Rapports/TP-SI-22-09C_RALA01-2022_HERG-GBHEeggs2022.pdf\n\n\nTP-SI-22-09\npdf\n3\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/TP-SI-22-09C_RALA01-2022_HERG-GBHEeggs2022.pdf\n\n\nCHEM-OC-21-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-21-08R.pdf\n\n\nCHEM-OC-21-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/FouBassan Rapports 1984-2019/CHEM-OC-21-08R.pdf\n\n\nCHEM-OC-22-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-22-05_HERGDeslauriers.pdf\n\n\nCHEM-OC-22-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/GoelandArgente 2017, 2022-23/CHEM-OC-22-05_HERGDeslauriers.pdf\n\n\nCHEM-OC-23-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/CHEM-OC-23-08_EggHERG_COEI_2023.pdf\n\n\nCHEM-OC-23-08\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/EideràDuvet Rapports 1972-2023/CHEM-OC-23-08_EggHERG_COEI_2023.pdf\n\n\nMET-THg-21-03\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/FouBassan Rapports 1984-2019/MET-THg-21-03.pdf\n\n\nMET-THg-21-03\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/MET-THg-21-03 - RALA01-2021_eggs.pdf\n\n\nTP-SI-21-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/FouBassan Rapports 1984-2019/TP-SI-21-05C.pdf\n\n\nTP-SI-21-05\npdf\n2\nC:/Users/VissaultS/Documents/03-Labo/Results Reports/TP-SI-21-05C_RALA01-2021.pdf\n\n\n\nOn selectionne le premier rapport en se basant sur le id (ex. BMK-PFC-23-01) pour éliminer les rapports dupliqués pour la suite de l’analyse. On s’assure de selectionner préférablement les pdfs si on dispose d’un docx et d’un document pdf pour le même identifiant de rapport de laboratoire.\n\nreports &lt;- reports |&gt; \n    # On retire les rapports qui sont dupliqués\n    dplyr::group_by(hash) |&gt;\n    dplyr::slice(1) |&gt;\n    dplyr::ungroup() |&gt;\n    # Si plusieurs extension de fichiers, on selectionne ceux en PDF préférablement, sinon .docx, sinon .doc en dernier recours.\n    dplyr::group_split(id) |&gt;\n    purrr::map(\\(g){\n        g |&gt; dplyr::arrange(factor(ext, levels = c('pdf', 'docx', 'doc'))) |&gt;\n        dplyr::slice(1)\n    }) |&gt;\n    dplyr::bind_rows()\n\nQuelques rapports de laboratoire demeurent au format doc et docx.\ndocs &lt;- reports |&gt; dplyr::filter(ext %in% c('doc', 'docx')) \ndocs |&gt; knitr::kable()\n\n\n\npath\nid\nhash\next\n\n\n\n\n\nAfin de faciliter l’extraction des métadonnées par programmation, on convertit les fichiers .doc et .docx en pdf.",
    "crumbs": [
      "Consolider les données",
      "Recensement des projets"
    ]
  },
  {
    "objectID": "tbl_projects.html#convertion-des-documents-word-en-pdf",
    "href": "tbl_projects.html#convertion-des-documents-word-en-pdf",
    "title": "Recensement des projets",
    "section": "Convertion des documents Word en pdf",
    "text": "Convertion des documents Word en pdf\nCette étape a été complété manuellement.",
    "crumbs": [
      "Consolider les données",
      "Recensement des projets"
    ]
  },
  {
    "objectID": "tbl_projects.html#extraire-les-métadonnées-du-rapport",
    "href": "tbl_projects.html#extraire-les-métadonnées-du-rapport",
    "title": "Recensement des projets",
    "section": "Extraire les métadonnées du rapport",
    "text": "Extraire les métadonnées du rapport\nNous souhaitons générer une liste de tous les projets basée sur les 71 rapports de laboratoire stockés dans le dossier 03-Labo/Comptes rendus de résultats. La première page de chaque rapport de laboratoire contient toutes les informations pertinentes pour produire cette liste.\nPour chaque rapport, nous vérifions s’il s’agit d’une image ou non. Si le rapport est une image, nous devons utiliser une reconnaissance optique de caractères (OCR) afin d’extraire le texte de la première page et d’obtenir toutes les métadonnées pertinentes. Si c’est un pdf ou un fichier word, nous importons la première page du document.\n\n# On détect si le document est une image\nreports &lt;- reports |&gt; dplyr::mutate(\n    filename = basename(path),\n    is_image = purrr::map2_lgl(path, ext, \\(p, e) {\n        if(e == \"pdf\"){\n            out &lt;- pdftools::pdf_text(p)\n            !all(nchar(out) &gt; 15)\n        } else {\n            FALSE\n        }\n    })\n)\n\n# On extrait le texte par OCR si c'est une image\nfrontpages &lt;- purrr::map2_vec(reports$path, reports$is_image, \\(p, i) {\n        ifelse(isTRUE(i), \n            pdftools::pdf_ocr_text(pdf = p, pages = 1),\n            pdftools::pdf_text(pdf = p)[[1]]\n        )\n    }) |&gt; tolower()\n\nUne fois le texte de la première page isolé, on applique une série d’opération d’extractions de texte à partir de la position de mots clés. On isole ainsi le titre du projet, l’ID du projet, la date etc.\n\nproject_id &lt;- purrr::map_vec(frontpages, \\(f){\n    stringr::str_extract(f, \"(?&lt;=(project: |project |projects|projet :)).*(?=\\n)\")\n}) |&gt; \n    toupper() |&gt; \n    stringr::word(1) |&gt; \n    stringr::str_replace_all(\"[.,]\", \"\") |&gt;\n    stringr::str_trim() |&gt;\n    dplyr::na_if(\"\")\n\nproject_leader &lt;- purrr::map_vec(frontpages, \\(f){\n        stringr::str_extract(f, \"(?&lt;=(project leader: |project leader |project manager: |manager: |study leader: |nom du requérant :)).*(?=\\n)\")\n    }) |&gt; \n    stringr::str_replace_all(c(\"[_|:]\" = \"\", \"[:digit:]\" = \"\", \"[.]$\" = \"\")) |&gt; \n    stringr::str_to_title() |&gt;\n    stringr::str_trim()\n\nproject_dates &lt;- frontpages |&gt;\n    purrr::map_vec(\\(f){\n        dates &lt;- stringr::str_extract(f, \"\\\\d{4}-\\\\d{2}-\\\\d{2}\")\n        if(is.na(dates)) {\n            dates &lt;- stringr::str_extract(f, \"(?&lt;=(date: )).*(?=\\n)\")\n        }\n        return(dates)\n    }) \n        \nreportsProject &lt;- data.frame(\n    report_id = reports$id, \n    report_access_path = stringr::str_replace_all(reports$path, \"C:/Users/VissaultS/Documents\", \"Z:\"), \n    project_id, project_leader, project_dates, project_title = NA\n)\n\nLe data.frame reportsProject est à la base du fichier “Z:\\07-Données BD_projects_list_extract_25032024.xlsx”.",
    "crumbs": [
      "Consolider les données",
      "Recensement des projets"
    ]
  },
  {
    "objectID": "tbl_projects.html#valider-lexistence-de-rapports-de-laboratoire-dans-le-dossier-01-projet-et-suivis",
    "href": "tbl_projects.html#valider-lexistence-de-rapports-de-laboratoire-dans-le-dossier-01-projet-et-suivis",
    "title": "Recensement des projets",
    "section": "Valider l’existence de rapports de laboratoire dans le dossier 01-Projet et suivis",
    "text": "Valider l’existence de rapports de laboratoire dans le dossier 01-Projet et suivis\nOn valide si certains de ces rapports ne se retrouvent pas dans le dossier 03-Labo/Comptes rendus. Ces rapports pourraient potentiellement nous interressés.\n\nfiles &lt;- list.files(\n    \"C:/Users/VissaultS/Documents/01-Projets et suivis\", \n    pattern = \"*.pdf|*.docx|*.doc\", recursive = TRUE, full.names = TRUE\n)\n\npotential_reports &lt;- data.frame(file = files[which(stringr::str_detect(files, regex_report_id))])\n\npotential_reports &lt;- potential_reports |&gt; dplyr::mutate(\n    id = stringr::str_extract(file, regex_report_id) |&gt; toupper(),\n    in_lab_report_folder = !(id %in% reports$id)\n) |&gt; dplyr::arrange(in_lab_report_folder) |&gt;\n    dplyr::mutate(file = stringr::str_replace(file, \"C:/Users/VissaultS/Documents/\", \"Z:\"))",
    "crumbs": [
      "Consolider les données",
      "Recensement des projets"
    ]
  }
]